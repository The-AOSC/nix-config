Author: The AOSC <the-aosc@tutamail.com>
Date:   Sat Dec 27 00:43:05 2025 +0500

    Revert "wayland: convert luminance values to libplacebo space"
    
    This reverts commit ae211f7f1b23b3dff7d611486eecfb787898e3a3.

diff --git a/video/out/wayland_common.c b/video/out/wayland_common.c
index b5b889b9d1..ca93e4ae5d 100644
--- a/video/out/wayland_common.c
+++ b/video/out/wayland_common.c
@@ -2159,35 +2159,10 @@ static void info_done(void *data, struct wp_image_description_info_v1 *image_des
     struct vo_wayland_state *wl = wd->wl;
     wp_image_description_info_v1_destroy(image_description_info);
     if (!wd->icc_file) {
+        wl->preferred_csp = wd->csp;
         MP_VERBOSE(wl, "Preferred surface feedback received:\n");
         log_color_space(wl->log, wd);
-        // Wayland luminances are always in reference to the reference luminance. That is,
-        // if max_luma == 2*ref_luma, then there is 2x headroom above paper white. On the
-        // other hand, libplacebo hardcodes PL_COLOR_SDR_WHITE as the reference luminance.
-        // We must scale all wayland values to correspond to the libplacebo scale,
-        // otherwise libplacebo will assume that there is too little or too much headroom
-        // when ref_luma != PL_COLOR_SDR_WHITE.
-        float a = wd->min_luma;
-        float b = (PL_COLOR_SDR_WHITE - PL_COLOR_HDR_BLACK) / (wd->ref_luma - a);
-        wd->csp.hdr.min_luma = (wd->csp.hdr.min_luma - a) * b + PL_COLOR_HDR_BLACK;
-        wd->csp.hdr.max_luma = (wd->csp.hdr.max_luma - a) * b + PL_COLOR_HDR_BLACK;
-        if (wd->csp.hdr.max_cll != 0)
-            wd->csp.hdr.max_cll  = (wd->csp.hdr.max_cll  - a) * b + PL_COLOR_HDR_BLACK;
-        if (wd->csp.hdr.max_fall != 0)
-            wd->csp.hdr.max_fall = (wd->csp.hdr.max_fall - a) * b + PL_COLOR_HDR_BLACK;
-        // Ensure that min_luma doesn't become negative.
-        wd->csp.hdr.min_luma = MPMAX(wd->csp.hdr.min_luma, 0.0);
-        // Since we want to do some exact comparisons of max_luma with PL_COLOR_SDR_WHITE,
-        // we need to round it.
-        if (fabsf(wd->csp.hdr.max_luma - PL_COLOR_SDR_WHITE) < 1e-2f) {
-            wd->csp.hdr.max_luma = PL_COLOR_SDR_WHITE;
-            if (wd->csp.hdr.max_cll != 0)
-                wd->csp.hdr.max_cll = MPMIN(wd->csp.hdr.max_cll, wd->csp.hdr.max_luma);
-            if (wd->csp.hdr.max_fall != 0)
-                wd->csp.hdr.max_fall = MPMIN(wd->csp.hdr.max_fall, wd->csp.hdr.max_luma);
-        }
-        wl->preferred_csp = wd->csp;
-        if (wd->csp.hdr.max_luma != PL_COLOR_SDR_WHITE && !pl_color_transfer_is_hdr(wd->csp.transfer)) {
+        if (wd->csp.hdr.max_luma > wd->ref_luma) {
             MP_VERBOSE(wl, "Setting preferred transfer to PQ for HDR output.\n");
             wl->preferred_csp.transfer = PL_COLOR_TRC_PQ;
         }

