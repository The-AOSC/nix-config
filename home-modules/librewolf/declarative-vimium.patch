--- a/lib/settings.js
+++ b/lib/settings.js
@@ -110,9 +110,11 @@ const Settings = {
       );
     }
 
-    let result = await chrome.storage.sync.get(null); // Get every key.
+    let result = (await chrome.storage.session.get("settings")).settings || {};
     result = this.migrateSettingsIfNecessary(result);
     result["settingsVersion"] = Utils.getCurrentVersion();
+    console.log("Current settings:");
+    console.log(result);
     this._settings = Object.assign(globalThis.structuredClone(defaultOptions), result);
   },
 
@@ -177,15 +179,7 @@ const Settings = {
     settings = this.migrateSettingsIfNecessary(settings);
     settings["settingsVersion"] = Utils.getCurrentVersion();
     const result = this.pruneOutDefaultValues(settings);
-    // If, after pruning, some keys were removed because their values are now equal to the default
-    // values, then explicitly clear those from storage. Otherwise they will remain.
-    // NOTE(philc): This kind of sharp edge is a reason to switch to storing the settings object as
-    // one big object, rather than as top-level keys in chrome.storage. The tradeoff is that each
-    // value in chrome-storage has a maximum size.
-    const resultKeys = Object.keys(result);
-    const removedKeys = Object.keys(settings).filter((key) => !resultKeys.includes(key));
-    await chrome.storage.sync.remove(removedKeys);
-    await chrome.storage.sync.set(result);
+    await chrome.storage.session.set({"settings": result});
     await this.load();
   },
 
@@ -204,7 +198,7 @@ const Settings = {
   // Used only by tests.
   async clear() {
     this._settings = null;
-    await chrome.storage.sync.clear();
+    await chrome.storage.session.clear("settings");
   },
 };
 
